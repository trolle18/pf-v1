<?php

class OCVMScan
{

    private $settings;
    private $scan_data = null;
    private $versions = array(
        'wp' => ONECOM_WP_CORE_VERSION,
        "plugins" => [],
        "themes" => []
    );
    private $http_error = false;
    private $http_response;
    private $http_args = array(
        'timeout' => 10,
        'httpversion' => '1.0',
        'compress' => false,
        'decompress' => true,
        'sslverify' => true,
        'stream' => false,
    );

    private $vulTemplate = array(
        'email_sent' => 0,
        'vuln_type' => [],
        'update_avail' => 0,
        'fixed_in' => "",
        'introduced_in' => ""
    );


    public function __construct()
    {
        $this->settings = new OCVMSettings();
        $this->setCron();
    }

    public function collectVersions(): void
    {

        // get all active plugins
        $activePlugins = get_site_option('active_plugins');

        // active plugins' slug and version
        foreach ($activePlugins as $activePlugin) {
            $this->versions['plugins'][] = array(
                "slug" => explode(DIRECTORY_SEPARATOR, $activePlugin)[0],
                "installed_version" => get_plugin_data(WP_PLUGIN_DIR . DIRECTORY_SEPARATOR . $activePlugin, false, false)['Version']
            );
        }

        // get active theme
        $theme = wp_get_theme();

        // active theme's slug and version
        $this->versions['themes'][] = array(
            "slug" => $theme->template,
            "installed_version" => $theme->version
        );
    }

    /**
     * Send versions of all plugins/themes/core
     */
    public function sendVersions()
    {
        // stats
        $this->sendVersionStats($this->versions);

        // http call
        $this->http_args['user-agent'] = 'WordPress/' . ONECOM_WP_CORE_VERSION . '; ' . home_url();
        $this->http_args['body'] = json_encode($this->versions);
        $this->http_response = wp_remote_post($this->settings::ocvm_endpoint, $this->http_args);
    }

    /**
     * Process http_response
     */
    public function processResponse()
    {
        if (is_wp_error($this->http_response)) {
            if (isset($this->http_response->errors['http_request_failed'])) {
                $this->http_error = __('Connection timed out', OC_VALIDATOR_DOMAIN);
            } else {
                $this->http_error = $this->http_response->get_error_message();
            }
        } else {
            if (wp_remote_retrieve_response_code($this->http_response) != 200) {
                $this->http_error = '(' . wp_remote_retrieve_response_code($this->http_response) . ') ' . wp_remote_retrieve_response_message($this->http_response);
            } else {
                $body = wp_remote_retrieve_body($this->http_response);
                $bodyArr = json_decode($body, 1);
                if (null !== $bodyArr['error']) {
                    error_log("Error reported by API endpoint --> " . $body);
                } else {
                    $this->scan_data = array_merge(
                        array(
                            'plugins' => (array)$bodyArr['data']['plugins'],
                            'themes' => (array)$bodyArr['data']['themes'],
                            'wp' => (array)$bodyArr['data']['wp']
                        )
                    );
                }
            }
        }
    }

    /**
     * Check if Vulnerability reported by Endpoint
     */
    public function vulnerabilityExists(): bool
    {
        if (
            empty($this->scan_data['wp']) &&
            empty($this->scan_data['plugins']) &&
            empty($this->scan_data['themes'])
        ) {
            return false;
        }
        return true;
    }

    /**
     * Get FQN of plugin by slug
     * @param $slug string Theme's stylesheet or Plugin's PHP dir name
     * @return string Name of the plugin/theme
     */
    protected function get_name_for_slug($slug, $type): string
    {
        if ("themes" === $type) {
            // theme headers
            $themeData = wp_get_theme($slug);
            return $themeData->get('Name');
        }

        require_once ABSPATH . 'wp-admin/includes/plugin.php';
        $plugin_files = get_plugins('/' . $slug);
        if (!$plugin_files) {
            return '';
        }
        $plugin_files = array_keys($plugin_files);
        $plugin_dir = $slug . '/' . reset($plugin_files);
        $pluginData = get_plugin_data(trailingslashit(WP_PLUGIN_DIR) . $plugin_dir);
        return $pluginData['Name'];
    }

    /**
     * Iterator
     */
    public function arrayIterator($items, $type = 'plugins')
    {

        $arrItems = [];
        foreach ($items as $slug => $vuls) {
            // find highest fix version across all the vulnerabilities found for this item
            $arrItems[$slug]["fixed_in"] = max(array_column($vuls['vulnerabilities'], 'fixed_in'));
            $arrItems[$slug]["name"] = $this->get_name_for_slug($slug, $type);
            $arrItems[$slug] = array_merge($arrItems[$slug], $vuls);

            // cleanup duplicate vulnerability codes
            $vulsArr = [];
            foreach ($arrItems[$slug]['vulnerabilities'] as $k => $v) {
                if (in_array($v['vuln_type'], $vulsArr)) {
                    unset($arrItems[$slug]['vulnerabilities'][$k]);
                    continue;
                }
                $vulsArr[] = $v['vuln_type'];
            }
        }
        return $arrItems;
    }

    /**
     * Save vulnerabilities in DB
     */
    public function saveVulnerabilities()
    {
        $existing = $this->settings->get();
        $dbData = array();
        //TODO: delete the entries of plugins/themes/core from $existing data if any of them dont exist now.
        // This is required to clean up stale data and to avoid sending/showing irrelevant mails/notifications.
        if (!empty($this->scan_data['plugins'])) {
            $dbData['plugins'] = $this->arrayIterator($this->scan_data['plugins']);
        }

        if (!empty($this->scan_data['themes'])) {
            $dbData['themes'] = $this->arrayIterator($this->scan_data['themes'], 'themes');
        }

        if (!empty($this->scan_data['wp']) && !empty($this->scan_data['wp']['vulnerabilities'])) {
            
            $temp = array_unique(array_column($this->scan_data['wp']['vulnerabilities'], 'vuln_type'));
            $unique_vul = array_intersect_key($this->scan_data['wp']['vulnerabilities'], $temp);
            shuffle($unique_vul);

            $wp_vuls    =   $unique_vul;

            $dbData['wp']['installed_version']      =   $this->scan_data['wp']['installed_version'];
            $dbData['wp']['fixed_in']               =   max(array_column($wp_vuls, 'fixed_in'));
            $dbData['wp']['vulnerabilities']        =   $wp_vuls;
            $dbData['wp']['name']                   =   "WordPress Core";
        }

        if (empty($existing['vulnerabilities'])) {
            $existing['vulnerabilities'] = $dbData;
        } else {
            //TODO: check if we really need to retain previously found vulnerabilities, because in all new scans, all the vulnerabilities should get detected together. i.e., Including old and new ones
            $existing['vulnerabilities'] = array_merge($existing['vulnerabilities'], $dbData);
        }

        // save all vulnerabilities
        $existing['vulnerabilities'] = $dbData;

        $this->settings->update($existing);
    }

    /**
     * Check and Display Vulnerabilities if any
     */
    public function manageVulnerabilities(): void
    {
        error_log("Scan started!");

        self::collectVersions();

        self::sendVersions();

        self::processResponse();

        if (false !== $this->http_error) {
            error_log("Error found -- " . $this->http_error);
            return;
            // stop execution and log error if required
        }

        if (null === $this->scan_data) {
            error_log("No data found from API response -- " . json_encode($this->http_response));
            return;
            // stop execution and log error if required
        }

        if (true !== self::vulnerabilityExists()) {
            error_log("No vulnerabilities found! All good! Exiting...");
            return;
        }

        error_log("Vulnerabilities found!");
        self::saveVulnerabilities();

        // get user's preferences
        $userSettings = $this->settings->get();
        $notifyAdmins = new OCVMSendEmails();

        if (1 == $userSettings['settings']['auto_update']) {

            // Auto-update items
            $autoUpdate = new OCVMAutoUpdates();
            $autoUpdate->updateItems();

            // check user's preferences for email type
            if (
                1 === $userSettings['settings']['notify_all'] &&
                1 === $userSettings['settings']['email_type']['email_fixed']
            ) {
                // send auto-update email
                $notifyAdmins->sendEmail("vulsFixed", $autoUpdate->updateAttempt);
            }

        } else {

            // check user's preferences for email type
            if (
                1 === $userSettings['settings']['notify_all'] &&
                1 === $userSettings['settings']['email_type']['email_detect']
            ) {
                // send vuls-found email
                $notifyAdmins->sendEmail();
            }
        }

    }


    /**
     * Set cron if not exists
     */
    public function setCron()
    {
        if (!wp_next_scheduled($this->settings::wpcron_hook)) {
            wp_schedule_event(
                time(),
                'daily',
                // TODO: enable 24 hours duration before real deployment
                // $this->settings->get()['scan_duration'],
                $this->settings::wpcron_hook
            );
        }
    }

    /**
     * Delete cron upon deactivation
     */
    public function deleteCron()
    {
        $timestamp = wp_next_scheduled('bl_cron_hook');
        wp_unschedule_event($timestamp, 'bl_cron_hook');
    }

    /**
     * Send version stats
     */
    public function sendVersionStats($ver = []): void
    {
        if (empty($ver)) {
            return;
        }
        class_exists('OCPushStats') ?
            OCPushStats::push_vul_monitor_stats('scan', 'setting', 'vulnerability_monitor', ['active_versions'=>$ver]) :
            '';
    }

}